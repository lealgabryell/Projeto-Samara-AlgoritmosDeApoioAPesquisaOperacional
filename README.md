# Aplicar Algoritmos de Apoio à Pesquisa Operacional

## 30/10/2024

![Markdown](https://img.shields.io/badge/Java-000000?style=for-the-badge&logo=openjdk)
<img alt="IntelliJ IDEA" src="https://img.shields.io/badge/IntelliJIDEA-000000.svg?style=for-the-badge&logo=intellij-idea&logoColor=white"/>
![Markdown](https://img.shields.io/badge/Markdown-000000?style=for-the-badge&logo=markdown)

# 👩🏽‍🏫 Professora

<a><img src="https://media.licdn.com/dms/image/v2/C4D03AQEVGoqRx6qddQ/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1644086391785?e=1735776000&v=beta&t=MczP1VVUo4Qtw3taZDhyKNITLvz-naMZNH-F5sDU_qM" width="200"></a><br><br>

🪪 **Samara Sampaio**<br>
💼 **Cientista de dados | SQL | Python | R | PowerBI | AWS**<br>
🎓 **Graduanda em Ciência da Computação - UFCG**<br>
🎓 **Mestranda em Ciência da Computação com ênfase em Sistemas Distribuídos - UFCG**<br>

<a href="https://www.linkedin.com/in/samara-sampaio-4b805b194/"><img src="https://img.shields.io/badge/LinkedIn-black?style=for-the-badge&logo=linkedin" width="100"></a>

# ✍🏻 Autores

<a><img src="https://gitlab.com/uploads/-/system/user/avatar/23003426/avatar.png" width="200"></a><br><br>

🪪 **Francinaldo Batista**<br>
💼 **AWS & Performance for Software Quality Engineering | React | Typescript | Java | Node.js | SQL | NoSQL**<br>
🎓 **Bacharelando em Sistemas de Informação - Unifacisa**<br>

<a href="https://www.linkedin.com/in/francinaldobatista"><img src="https://img.shields.io/badge/LinkedIn-black?style=for-the-badge&logo=linkedin" width="100"></a>

---

<a><img src="https://media.licdn.com/dms/image/v2/D4D03AQGVK7bUlOK6QQ/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1720743089396?e=1735776000&v=beta&t=krdcujWe2O-loyEe3MdENP2Ddd6NcNuYLYK2duF6LxY" width="200"></a><br><br>

🪪 **Gabryell Leal**<br>
💼 **Professor de inglês Yázigi | Java | JavaScript | Node | React | PowerBi**<br>
🎓 **Bacharelando em Sistemas de Informação - Unifacisa**<br>

<a href="https://www.linkedin.com/in/gabryell-leal-rocha-1762392a0/"><img src="https://img.shields.io/badge/LinkedIn-black?style=for-the-badge&logo=linkedin" width="100"></a>

---

<a><img src="https://media.licdn.com/dms/image/v2/D4D03AQHpBH3e1uO9ZQ/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1725280747762?e=1735776000&v=beta&t=8Sbd2UbZvaYXezj4cQPEnVV1Cw-uZ1qFnjwEnpoPwz4" width="200"></a><br><br>

🪪 **Pablo Selares**<br>
💼 **Desenvolvedor FrontEnd HTML | CSS | REACT | MONGODB**<br>
🎓 **Bacharelando em Sistemas de Informação - Unifacisa**<br>

<a href="https://www.linkedin.com/in/pablo-selares-274424278/"><img src="https://img.shields.io/badge/LinkedIn-black?style=for-the-badge&logo=linkedin" width="100"></a>

---

<a><img src="https://media.licdn.com/dms/image/v2/D4D03AQF6e2Mekm9SKA/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1715113844927?e=1735776000&v=beta&t=AjxxbY9Bz1MgOAn0nHwKBSMwhZ9Zmz73JIMUJbGoSq4" width="200"></a><br><br>

🪪 **Talles Oliveira**<br>
💼 **Análista de finanças | Python | CSS | JavaScript | React | SQL**<br>
🎓 **Bacharelando em Sistemas de Informação - Unifacisa**<br>

<a href="https://www.linkedin.com/in/talles-oliveira-98976827b/"><img src="https://img.shields.io/badge/LinkedIn-black?style=for-the-badge&logo=linkedin" width="100"></a>

---

<a><img src="https://media.licdn.com/dms/image/v2/D5603AQHXGFgqw43VDg/profile-displayphoto-shrink_400_400/profile-displayphoto-shrink_400_400/0/1730466709428?e=1736380800&v=beta&t=Goh1RbquJNiOR7I-wkhWvSCtPwPYL_F1C1W7EQ659GM" width="200"></a><br><br>

🪪 **Eduardo Sena**<br>
💼 **Desenvolvedor front-end | HTML | CSS | JavaScript | Python | Java | SQL | API**<br>
🎓 **Bacharelando em Sistemas de Informação - Unifacisa**<br>

<a href="https://www.linkedin.com/in/talles-oliveira-98976827b/"><img src="https://img.shields.io/badge/LinkedIn-black?style=for-the-badge&logo=linkedin" width="100"></a>
<br><br>

# 1° Fase - Implementação de uma Lista Encadeada Simples
## 🎯 Funções a implementar

1. **Adicionar Elemento em uma Posição Específica**
2. **Remover um Elemento**
3. **Inverter a Lista**
4. **Retornar o Nó que Está no Meio da Lista**
5. **Remover Nós Duplicados**

Em cada método implementado, precisamos da informação do custo: <br>**Calcule e comente a complexidade temporal desta operação.**

## 🔎 Observações

- O código deve estar bem documentado, explicando a lógica de cada função e os passos que foram seguidos.
- Deve haver uma classe dedicada para testar as funcionalidades da lista encadeada, como, por exemplo, uma classe Main que chama as diferentes operações e exibe os resultados de cada uma delas.
- Os grupos deve ser de no máximo 5 pessoas.

## 📶 Pontuação

O projeto inteiro vale **3,0 pontos**.

## Código: 2,5

- Cada função implementada corretamente: 0,5
  - Adicionar Elemento em uma Posição Específica
  - Remover um Elemento
  - Inverter a Lista
  - Retornar o Nó que Está no Meio da Lista
  - Remover Nós Duplicados

## Apresentação: 0,5

- A apresentação ocorrerá no dia 06/11, na primeira aula após a entrega do projeto.
- O grupo completo apresentará para a professora.
- Haverá um sorteio para determinar qual integrante de cada grupo explicará qual funcionalidade
- Os alunos deverão detalhar a lógica de implementação, justificar por que a solução funciona daquela maneira e discutir o custo de cada função.
- Explicação da função: 0,5. Essa nota será individual, dependendo da explicação de cada integrante.
<br><br>

# 2° Fase - Implementação do Problema da Mochila Fracionária, com implementação de um algoritmo de ordenação

## 📖 Descrição do problema
O Problema da Mochila Fracionária é um clássico da ciência da computação que demonstra o poder dos algoritmos gulosos. Imagine que você é um aventureiro com uma mochila de capacidade limitada e precisa escolher quais itens levar. Cada item tem um peso e um valor associado, e o objetivo é maximizar o valor total dos itens carregados sem exceder a capacidade da mochila.

No caso da mochila fracionária, você pode levar frações de itens, ou seja, é permitido dividir o peso de um item e levar apenas uma parte dele.

## 🤹‍♂️ Exemplo
- Capacidade da mochila: 50 kg
- Itens disponíveis:
  - Item A: Peso = 10 kg, Valor = $60
  - Item B: Peso = 20 kg, Valor = $100
  - Item C: Peso = 20 kg, Valor = $120

O objetivo é maximizar o valor total dos itens sem exceder a capacidade da mochila. No caso da mochila fracionária, podemos levar frações dos itens. O resultado esperado seria:
- Item A: 10 kg, valor = $60
- Item B: 20 kg, valor = $100
- 2/3 do Item C: 13,33 kg, valor = $80

Valor total = $60 + $100 + $80 = $240


## 🎯 Funções a implementar

1. **Função de Ordenação dos Itens:**
    - A ordenação dos itens será feita de acordo com a relação entre valor e peso. A ideia é ordenar os itens com base no valor por unidade de peso (valor/peso), pois isso nos ajuda a determinar quais itens são mais "rentáveis" para carregar.
    - A ordenação deve ser feita utilizando um algoritmo simples estudado em sala, como Bubble Sort ou Selection Sort.
2. **Função Principal do Algoritmo (Mochila Fracionária):**
    - Entrada: Lista de itens (peso, valor) e a capacidade máxima da mochila.
    - Saída: Lista dos itens selecionados (incluindo as frações dos itens, se necessário) e o valor total da mochila.
    - O algoritmo deverá seguir as etapas:
      1. Ordenar os itens de acordo com o valor por unidade de peso.
      1. Iterar sobre os itens, incluindo-os na mochila até que a capacidade máxima seja atingida.
      1. Se um item não couber completamente na mochila, adicionar a fração do item que cabe e terminar o processo.
      1. Retornar o valor total da mochila e a lista de itens fracionados.
3. **Função de Cálculo do Valor Total:**
    - A função será responsável por calcular o valor total da mochila, levando em consideração as frações dos itens.
4. **Função de Exibição de Resultados:**
    - Mostrar os itens que foram selecionados (incluindo frações, se necessário) e o valor total que foi alcançado.


## 🔎 Observações
- **Complexidade do Algoritmo:** O algoritmo de ordenação escolhido (Bubble Sort ou Selection Sort) tem uma complexidade de O(n²), o que é aceitável para a quantidade limitada de itens, mas pode não ser eficiente para grandes quantidades de dados.

- **Frações dos Itens:** Como estamos lidando com a versão fracionária do problema, a fração de um item será calculada com base no espaço restante da mochila e no peso do item. Caso o item não possa ser carregado completamente, devemos considerar a fração do item que cabe na mochila.

- **Estruturas de Dados:** A principal estrutura de dados que será utilizada será a lista de itens, cada um representado por uma tupla contendo o peso e o valor. Outra estrutura importante será a variável para o valor total da mochila.

- **Capacidade da Mochila:** A capacidade da mochila será um número fixo (50 kg, no exemplo), mas esse valor pode ser alterado para testar o algoritmo com diferentes entradas.

- **Importância da Ordenação:** A escolha do algoritmo de ordenação é crucial, pois ela determinará a eficiência e a otimização do valor total. A ordenação permite que o algoritmo escolha sempre o item com melhor "custo-benefício" (valor por peso) primeiro, o que é o cerne da abordagem gulosa.

## 🗺️ Passos para Implementação
- **Implementação do Algoritmo de Ordenação:** Comece implementando o algoritmo de ordenação escolhido para ordenar os itens pela razão valor/peso.
- **Desenvolvimento da Função Principal:** Crie a função que resolverá o problema da mochila fracionária, utilizando o algoritmo de ordenação.
- **Cálculo do Valor Total:** Implemente a lógica que calcula o valor total da mochila com base nos itens carregados.
- **Exibição do Resultado:** Implemente uma função que exibe quais itens foram carregados, incluindo as frações, e qual foi o valor total da mochila.

## 📶 Pontuação

O projeto inteiro vale **3,0 pontos**.

## Código: 2,5

- Cada função implementada corretamente: 1,25
  - Algoritmo de Ordenação
  - Algoritmo Guloso

## Apresentação: 0,5

- A apresentação ocorrerá no dia 04/12, na primeira aula após a entrega do projeto.
- O grupo completo apresentará para a professora.
- Os alunos deverão detalhar a lógica de implementação, justificar por que a solução funciona daquela maneira e discutir o custo de cada função.

# ⚖ License

[![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)

